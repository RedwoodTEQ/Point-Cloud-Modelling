import { ModelDto } from "../dto/models.model";
import { exec } from "child_process";
import debug from "debug";
import * as fs from "fs";
import * as path from "path";
import {errorLogger} from "express-winston";

const fsPromise = fs.promises;

const log: debug.IDebugger = debug('app:in-memory-dao');

/**
 * Data access object of Model.
 * So far all models are stored as static resource in local disk.
 */
class ModelsDao {
    private static instance: ModelsDao;
    models: ModelDto[] = [];

    constructor() {
        log('Create new instance of ModelsDao');
    }

    static getInstance(): ModelsDao {
        if(!ModelsDao.instance) {
            ModelsDao.instance = new ModelsDao();
        }

        return ModelsDao.instance;
    }

    async addModel(model: ModelDto) {
        // TODO
        return null;
    }

    /**
     * Read files in model root path, which is defined as environment variable `MODEL_ROOT_PATH`.
     * Return files:
     * 1. `.las` and `.laz` generated by laser scanner.
     * 2. The index file `ept.json` of Entwine data bundle.
     */
    async getModels(): Promise<ModelDto[] | Error> {
        const modelRootPath = process.env.MODEL_ROOT_PATH;

        if(!modelRootPath) {
            return new Error('Environment variable MODEL_ROOT_PATH is undefined.');
        }

        if(!fs.existsSync(modelRootPath)) {
            return new Error(`Environment variable MODEL_ROOT_PATH: ${modelRootPath} is not exist.`);
        }

        const stat = await fsPromise.stat(modelRootPath);
        if(!stat || !stat.isDirectory()) {
            return new Error(`${modelRootPath} is not exist or it is not a directory.`);
        }

        /**
         * Recursively read files.
         */
        const readFileAsync = async (dir: string, outFiles: string[]) => {
            const names = await fsPromise.readdir(dir);
            for (const name of names) {
                const pathName = path.join(dir, name);
                const pathStat = await fsPromise.stat(pathName);
                if(pathStat.isDirectory()) {
                    await readFileAsync(pathName, outFiles);
                } else {
                    const ext = path.extname(pathName);
                    const filename = path.basename(pathName);
                    const parentDir = path.basename(path.dirname(pathName));
                    // Hard coding: Those `.laz` files generated by Entwine are located at folder `ept-data`.
                    if( ((ext === '.laz' || ext === '.las') && parentDir !== 'ept-data') || filename === 'ept.json') {
                        outFiles.push(pathName);
                    }
                }
            }
        }

        try {
            const modelPaths: string[] = [];
            const models: ModelDto[] = [];
            await readFileAsync(modelRootPath, modelPaths);
            modelPaths.forEach(_path => {
                models.push({
                    id: '',
                    name: path.basename(_path),
                    path: _path,
                });
            })
            return models;
        } catch (e) {
            return new Error(e);
        }
    }

    async getModelById(modelId: string) {
        // TODO
        return this.models.find((model: { id: string; }) => model.id === modelId);
    }

    async getModelByName(modelName: string) {
        // TODO
        return this.models.find((model: { name: string; }) => model.name === modelName);
    }

    async getModelByPath(modelPath: string) {
        // TODO
        return this.models.find((model: { path: string; }) => model.path === modelPath);
    }

    /**
     * As a demo, it only process `.laz` or `.las` file by Entwine.
     */
    async processModelByPath(
        modelPath: string, command: string
    ): Promise<{status: string, output: string, error: string} | Error> {
        const modelRootPath = process.env.MODEL_ROOT_PATH;

        log(`--> modelRootPath: ${modelRootPath}`);
        if(!modelRootPath) {
            return new Error('Environment variable MODEL_ROOT_PATH is undefined.');
        }

        if(!fs.existsSync(modelRootPath)) {
            return new Error(`Environment variable MODEL_ROOT_PATH: ${modelRootPath} is not exist.`);
        }

        let stat = await fsPromise.stat(modelRootPath);
        if(!stat || !stat.isDirectory()) {
            return new Error(`${modelRootPath} is not exist or it is not a directory.`);
        }

        if(!modelRootPath) {
            return new Error('')
        }

        const fullpath = path.resolve(modelRootPath, modelPath);

        log(`--> fullpath: ${fullpath}`);

        if(!fs.existsSync(fullpath)) {
            return new Error(`${modelPath} is not exist.`);
        }
        stat = await fsPromise.stat(fullpath);
        if(!stat || stat.isDirectory()) {
            return new Error(`${fullpath} is not a file but a directory.`);
        }

        const ext = path.extname(fullpath);
        if(ext !== '.laz' && ext !== '.las') {
            return new Error(`Do not support format ${ext}.`);
        }
        if(command !== 'entwine') {
            return new Error(`Do not support command ${command}. So far it only supports command 'entwine'.`);
        }


        return await this.processModelByEntwine(fullpath);
    }

    /**
     * As a demo, it only process `.laz` or `.las` file by Entwine.
     */
    async processModelByEntwine(modelPath: string): Promise<{status: string, output: string, error: string}> {
        const modelDir = path.dirname(modelPath);
        const ext = path.extname(modelPath);
        const outputDir = path.join(modelDir, `${path.basename(modelPath, ext)}_entwine`);

        log('--> modelPath: ', modelPath);
        log('--> outputDir: ', outputDir);

        const result = {
            status: '',
            output: '',
            error: '',
        };
        return new Promise(resolve => {
            exec(
                `entwine build -i ${modelPath} -o ${outputDir}`,
                (error, stdout, stderr) => {
                    if(!error) {
                        result.status = 'OK';
                        result.output = path.join(outputDir, 'ept.json');
                    } else {
                        result.error = stderr;
                    }

                    resolve(result);
                });
        });
    }
}

export default ModelsDao.getInstance();